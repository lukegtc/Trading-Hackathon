{"filter":false,"title":"utils.py","tooltip":"/TraderBot/utils.py","undoManager":{"mark":12,"position":12,"stack":[[{"start":{"row":0,"column":0},"end":{"row":225,"column":0},"action":"insert","lines":["import time","import numpy as np","","","class Calculator:","    def __init__(self, exchange, instruments, undercut_constant=0.8):","        self.exchange = exchange","        self.LIQUID_INSTRUMENT, self.ILLIQUID_INSTRUMENT = instruments","        self.UC = undercut_constant","","    def get_positions(self):","        \"\"\"","        Queries the exchange for the current positions.","        Returns:","            (tuple): The liquid and illiquid positions.","        \"\"\"","        positions = self.exchange.get_positions()","        liquid_position = positions[self.LIQUID_INSTRUMENT]","        illiquid_position = positions[self.ILLIQUID_INSTRUMENT]","        return liquid_position, illiquid_position","    ","    def get_books(self, requery=True, requery_time=0.15):","        \"\"\"","        Queries the exchange for the current order books.","        Args:","            requery (bool): Whether or not to requery the exchange for the order books if they are empty.","            requery_time (float): The time to wait between requerying the exchange for the order books.","        Returns:","            (tuple): The liquid and illiquid order books.","        \"\"\"","        liquid_book = self.exchange.get_last_price_book(self.LIQUID_INSTRUMENT)","        illiquid_book = self.exchange.get_last_price_book(self.ILLIQUID_INSTRUMENT)","        if requery:","            while not (liquid_book.bids and liquid_book.asks and illiquid_book.bids and illiquid_book.asks):","                liquid_book = self.exchange.get_last_price_book(self.LIQUID_INSTRUMENT)","                illiquid_book = self.exchange.get_last_price_book(self.ILLIQUID_INSTRUMENT)","                time.sleep(requery_time)","        ","        return liquid_book, illiquid_book","","    def get_best_ask_price(self, order_book):","        \"\"\"","        Returns the lowest ask price from the exchange order book.","        Args:","            order_book (PriceBook): The order book to get the lowest ask price from.","        Returns:","            (float): The lowest ask price.","        \"\"\"","        if not order_book:","            raise ValueError(\"Order book is empty.\")","","        # Asks are sorted from lowest to highest.","        return order_book.asks[0].price","","    def get_best_bid_price(self, order_book):","        \"\"\"","        Returns the highest bid price from the exchange order book.","        Args:","            order_book (PriceBook): The order book to get the highest bid price from.","        Returns:","            (float): The highest bid price.","        \"\"\"","        if not order_book:","            raise ValueError(\"Order book is empty.\")","    ","        # Bids are sorted from higest to lowest.","        return order_book.bids[0].price","","    def get_bid_ask_spread(self, order_book):","        \"\"\"","        Returns the spread between the highest bid and lowest ask.","        Args:","            order_book (PriceBook): The order book to get the spread from.","        Returns:","            (float): The spread between the highest bid and lowest ask.","        \"\"\"","        return self.get_best_ask_price(order_book) - self._get_best_bid_price(order_book)","","    def get_mid_price(self, order_book):","        \"\"\"","        Returns the mid price of the given order book.","        Args:","            order_book (PriceBook): The order book to get the mid price from.","        Returns:","            (float): The mid price of the given order book.","        \"\"\"","        if not order_book:","            raise ValueError(\"Order book is empty.\")","","        # The mid price is the average of the highest bid and lowest ask.","        return (self._get_best_bid_price(order_book) + self.get_best_ask_price(order_book)) / 2","","    def get_undercut_bid_price(self, order_book):","        \"\"\"","        Returns the undercut bid price of the given order book.","        Args:","            order_book (PriceBook): The order book to get the undercut bid price from.","        Returns:","            (float): The undercut bid price of the given order book.","        \"\"\"","        if not order_book:","            raise ValueError(\"Order book is empty.\")","","        mid_price = self.get_mid_price(order_book)","        spread = self.get_bid_ask_spread(order_book)","        return mid_price - (0.5 * spread * self.UC)","","    def get_undercut_illiquid_ask_price(self, order_book):","        \"\"\"","        Returns the undercut ask price of the given order book.","        Args:","            order_book (PriceBook): The order book to get the undercut ask price from.","        Returns:","            (float): The undercut ask price of the given order book.","        \"\"\"","        if not order_book:","            raise ValueError(\"Order book is empty.\")","","        mid_price = self.get_mid_price(order_book)","        spread = self.get_bid_ask_spread(order_book)","        return mid_price + (0.5 * spread * self.UC)","","","    def get_next_ask_price(self, liquid_book, illiquid_book):","        \"\"\"","        Calculates the next ask price for the illiquid instrument.","        Args:","            liquid_book (PriceBook): The liquid order book.","            illiquid_book (PriceBook): The illiquid order book.","        Returns:","            (float): The next ask price for the illiquid instrument.","            (float): The difference between the next ask price and best ask price on the exchange.","        \"\"\"","        best_liquid_ask = self.get_best_ask_price(liquid_book)","        best_illiquid_ask = self.get_best_ask_price(illiquid_book)","        undercut_illiquid_ask = self.get_undercut_illiquid_ask_price(illiquid_book)","","        if best_liquid_ask >= best_illiquid_ask:","            next_ask_price = best_liquid_ask","        else:","            next_ask_price = max(undercut_illiquid_ask, (best_liquid_ask + best_illiquid_ask) / 2)","","        illiquid_ask_delta = next_ask_price - best_illiquid_ask","","        return next_ask_price, illiquid_ask_delta","","    def get_next_bid_price(self, liquid_book, illiquid_book):","        \"\"\"","        Calculates the next bid price for the illiquid instrument.","        Args:","            liquid_book (PriceBook): The liquid order book.","            illiquid_book (PriceBook): The illiquid order book.","        Returns:","            (float): The next bid price for the illiquid instrument.","            (float): The difference between the next bid price and best bid price on the exchange.","        \"\"\"","        best_liquid_bid = self.get_best_bid_price(liquid_book)","        best_illiquid_bid = self.get_best_bid_price(illiquid_book)","        undercut_illiquid_bid = self.get_undercut_bid_price(illiquid_book)","","        if best_liquid_bid < best_illiquid_bid:","            next_bid_price = best_liquid_bid","        else:","            next_bid_price = min(undercut_illiquid_bid, (best_liquid_bid + best_illiquid_bid) / 2)","","        illiquid_bid_delta = next_bid_price - best_illiquid_bid","","        return next_bid_price, illiquid_bid_delta","","","    def get_next_ask_volume(self, liquid_position, illiquid_position, illiquid_ask_delta, MAX_VOLUME=30, VOL_FACTOR=0.5, VOL_LIMIT=150):","        position_diff = liquid_position - illiquid_position","        volume_exp = VOL_FACTOR / (illiquid_ask_delta + 0.01)","        volume_base = - MAX_VOLUME * ( np.sin(position_diff/1000 * np.pi/2) * 0.5 + 0.5 )","        new_ask_volume = volume_base ** volume_exp","","        if abs(illiquid_position - new_ask_volume) > VOL_LIMIT:","            new_ask_volume = (VOL_LIMIT - abs(illiquid_position)) * np.sign(new_ask_volume)","","        return int(new_ask_volume)","","","    def get_next_bid_volume(self, liquid_position, illiquid_position, illiquid_bid_delta, MAX_VOLUME=30, VOL_FACTOR=0.5, VOL_LIMIT=150):","        position_diff = illiquid_position - liquid_position","        volume_exp = VOL_FACTOR / (illiquid_bid_delta + 0.01)","        volume_base = - MAX_VOLUME * ( np.sin(position_diff/1000 * np.pi/2) * 0.5 + 0.5 )","        new_bid_volume = volume_base ** volume_exp","        # new_B_bid_volume <=>  new_bid_volume","        # illiquid_position <=> B_pretrade_volume","        if abs(illiquid_position + new_bid_volume) > VOL_LIMIT:","            new_bid_volume = (VOL_LIMIT - abs(illiquid_position)) * np.sign(new_bid_volume)","            ","            # self.new_B_bid_volume = (vol_limit - abs(self.B_pretrade_volume))*mysign(new_B_bid_volume) ","            ","        return int(new_bid_volume)","","    def get_next_bid(self):","        \"\"\"","        Returns the next bid (price and volume) for the illiquid instrument.","        Returns:","            (float): The next bid price for the illiquid instrument.","            (int): The next bid volume for the illiquid instrument.","        \"\"\"","        liquid_book, illiquid_book = self.get_order_book()","        liquid_position, illiquid_position = self.get_position()","","        next_bid_price, price_delta = self.get_next_bid_price(liquid_book, illiquid_book)","        next_bid_volume = self.get_next_bid_volume(liquid_position, illiquid_position, price_delta)","","        return next_bid_price, next_bid_volume","","    def get_next_ask(self):","        \"\"\"","        Returns the next ask (price and volume) for the illiquid instrument.","        Returns:","            (float): The next ask price for the illiquid instrument.","            (int): The next ask volume for the illiquid instrument.","        \"\"\"","        liquid_book, illiquid_book = self.get_order_book()","        liquid_position, illiquid_position = self.get_position()","","        next_ask_price, volume_delta = self.get_next_ask_price(liquid_book, illiquid_book)","        next_ask_volume = self.get_next_ask_volume(liquid_position, illiquid_position, volume_delta)","","        return next_ask_price, next_ask_volume",""],"id":1}],[{"start":{"row":224,"column":46},"end":{"row":225,"column":0},"action":"remove","lines":["",""],"id":2}],[{"start":{"row":224,"column":46},"end":{"row":225,"column":0},"action":"insert","lines":["",""],"id":3},{"start":{"row":225,"column":0},"end":{"row":225,"column":8},"action":"insert","lines":["        "]},{"start":{"row":225,"column":8},"end":{"row":226,"column":0},"action":"insert","lines":["",""]},{"start":{"row":226,"column":0},"end":{"row":226,"column":8},"action":"insert","lines":["        "]}],[{"start":{"row":226,"column":4},"end":{"row":226,"column":8},"action":"remove","lines":["    "],"id":4},{"start":{"row":226,"column":0},"end":{"row":226,"column":4},"action":"remove","lines":["    "]}],[{"start":{"row":226,"column":0},"end":{"row":227,"column":0},"action":"insert","lines":["",""],"id":5}],[{"start":{"row":227,"column":0},"end":{"row":327,"column":44},"action":"insert","lines":["class OrderHandler:","    \"\"\"","    Wrapper class to insert, delete, and update orders","    @author: Nidhish","    \"\"\"","","    def __init__(self, exchange, INSTRUMENTS):","        self.exchange = exchange","        self.INSTRUMENTS = INSTRUMENTS","        self.bids = {}","        self.asks = {}","        ","","    def place_order(self, instrument_id, price, volume, side, order_type):","        \"\"\"","        Places an order on the exchange.","        Args:","            instrument_id (str): The instrument to place the order on.","            price (float): The price to place the order at.","            volume (int): The volume to place the order for.","            side (str): The side to place the order on ['bid' / 'ask'].","            order_type (str): The order type to place the order as ['limit', 'ioc'].","        Returns:","            order_id (int): The id of the order that was placed.","        \"\"\"","        order_id = self.exchange.insert_order(instrument_id, price, volume, side, order_type)","","        return order_id","","    def delete_order(self, instrument_id, order_id):","        \"\"\"","        Deletes an order from the exchange.","        Args:","            instrument_id (str): The instrument to delete the order for.","            order_id (int): The id of the order to delete.","        Returns:","            success (bool): Whether the order was successfully deleted.","        \"\"\"","        success = self.exchange.delete_order(instrument_id, order_id)","        return success","        ","    def update_outstanding_orders(self):","        \"\"\"","        Update the outstanding limit orders for all instruments.","        \"\"\"","        for instrument in self.INSTRUMENTS:","            orders = self.exchange.get_outstanding_orders(instrument).values()","            self.asks[instrument] = sorted([o for o in orders if o.side == \"ask\"], key = lambda x: x.price)","            self.bids[instrument] = sorted([o for o in orders if o.side == \"bid\"], key = lambda x: x.price)","    ","    def get_best_bid(self, instrument):","        \"\"\"","        Returns the highest bid for the given instrument.","        Args:","            instrument (str): The instrument to get the bid for.","        Returns:","            bid (Order): Order object for the higest bid.","        \"\"\"","        # The bids are sorted in ascending order, so highest bid is last.","        bids = self.bids[instrument]","        return bids[-1] if bids else None","            ","                ","    def get_best_ask(self, instrument):","        \"\"\"","        Returns the lowest ask for the given instrument.","        Args:","            instrument (str): The instrument to get the ask for.","        Returns:","            ask (Order): Order object for the lowest ask. If ther are","            no asks then None is returned.","            asks <list>","            asks[0] type <OrderStatus>","        \"\"\"","        # The bids are sorted in ascending order, so highest bid is last.","        asks = self.asks[instrument]","        return asks[0] if asks else None","    ","    ","    def get_ask_volume(self, instrument):","        \"\"\"","        Returns the total volume of all outstanding asks.","        Args:","            instrument (str): The instrument to get the ask volume for.","        Returns:","            volume (int): The total volume of all outstanding asks.","        \"\"\"","        asks = self.asks[instrument]","        return sum([o.volume for o in asks])","        ","        ","    def get_bid_volume(self, instrument):","        \"\"\"","        Returns the total volume of all outstanding asks.","        Args:","            instrument (str): The instrument to get the ask volume for.","        Returns:","            volume (int): The total volume of all outstanding asks.","        \"\"\"","        bids = self.bids[instrument]","        return sum([o.volume for o in bids])"],"id":6}],[{"start":{"row":76,"column":58},"end":{"row":76,"column":59},"action":"remove","lines":["_"],"id":7}],[{"start":{"row":90,"column":21},"end":{"row":90,"column":22},"action":"remove","lines":["_"],"id":8}],[{"start":{"row":203,"column":46},"end":{"row":203,"column":56},"action":"remove","lines":["order_book"],"id":9},{"start":{"row":203,"column":46},"end":{"row":203,"column":47},"action":"insert","lines":["b"]},{"start":{"row":203,"column":47},"end":{"row":203,"column":48},"action":"insert","lines":["o"]},{"start":{"row":203,"column":48},"end":{"row":203,"column":49},"action":"insert","lines":["o"]},{"start":{"row":203,"column":49},"end":{"row":203,"column":50},"action":"insert","lines":["k"]},{"start":{"row":203,"column":50},"end":{"row":203,"column":51},"action":"insert","lines":["s"]}],[{"start":{"row":203,"column":42},"end":{"row":203,"column":51},"action":"remove","lines":["get_books"],"id":10},{"start":{"row":203,"column":42},"end":{"row":203,"column":51},"action":"insert","lines":["get_books"]}],[{"start":{"row":204,"column":62},"end":{"row":204,"column":63},"action":"insert","lines":["s"],"id":11}],[{"start":{"row":218,"column":46},"end":{"row":218,"column":56},"action":"remove","lines":["order_book"],"id":12},{"start":{"row":218,"column":46},"end":{"row":218,"column":47},"action":"insert","lines":["b"]},{"start":{"row":218,"column":47},"end":{"row":218,"column":48},"action":"insert","lines":["o"]},{"start":{"row":218,"column":48},"end":{"row":218,"column":49},"action":"insert","lines":["o"]},{"start":{"row":218,"column":49},"end":{"row":218,"column":50},"action":"insert","lines":["k"]},{"start":{"row":218,"column":50},"end":{"row":218,"column":51},"action":"insert","lines":["s"]}],[{"start":{"row":219,"column":62},"end":{"row":219,"column":63},"action":"insert","lines":["s"],"id":13}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":215,"column":31},"end":{"row":215,"column":31},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1648991964245,"hash":"6c6270649425d2320c80cd83d66d5c0a10287307"}